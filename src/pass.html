<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - postprocessing - masking</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="main.css">
	</head>
	<body>

		<div id="container"></div>

		<!-- Import maps polyfill -->
		<!-- Remove this when import maps will be widely supported -->
		<script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>

		<script type="importmap">
			{
				"imports": {
					"three": "https://unpkg.com/three@0.155.0/build/three.module.js",
                    "three/addons/": "https://unpkg.com/three@0.155.0/examples/jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three';

			import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
			import { TexturePass } from 'three/addons/postprocessing/TexturePass.js';
			import { ClearPass } from 'three/addons/postprocessing/ClearPass.js';
            import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
			import { MaskPass, ClearMaskPass } from 'three/addons/postprocessing/MaskPass.js';
			import { OutputPass } from 'three/addons/postprocessing/OutputPass.js';

            import { FontLoader } from 'three/addons/loaders/FontLoader.js';

			let camera, composer, renderer;
			let box;

            const scene1 = new THREE.Scene();
            const scene2 = new THREE.Scene();

			init();
			animate();

			function init() {

				camera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 1, 1000 );
				camera.position.z = 10;

                const boxMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 }); // Red color
                box = new THREE.Mesh(new THREE.BoxGeometry(8, 2, 4), boxMaterial);
                box.position.z = -5; // Same Z position as text
                scene1.add(box);
				
                renderer = new THREE.WebGLRenderer();
                renderer.setClearColor(0xe0e0e0);
                renderer.setPixelRatio(window.devicePixelRatio);
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.autoClear = false;
                document.body.appendChild(renderer.domElement);

	
                //load text
                const loader = new FontLoader();
                loader.load('fonts/helvetiker_regular.typeface.json', function (font) {

                    const color = 0xffffff;

                    const matLite = new THREE.MeshBasicMaterial({
                        color: color,
                        transparent: false,
                        side: THREE.DoubleSide
                    });

                    const message = '   Three.js\nSimple text.';

                    const shapes = font.generateShapes(message, 1);

                    const geometry = new THREE.ShapeGeometry(shapes);

                    geometry.computeBoundingBox();

                    const xMid = -0.5 * (geometry.boundingBox.max.x - geometry.boundingBox.min.x);
                    geometry.translate(xMid, 0, 0);

                    const text = new THREE.Mesh(geometry, matLite);
                    text.position.z = -5; // Change the Z position
                    scene2.add(text);

                });

                // Clear everything at the beginning
                const clearPass = new ClearPass();

                // Render the box (the mask)
                const maskPass1 = new MaskPass(scene1, camera);

                // Render the text, which will be masked by the box
                const renderPass2 = new RenderPass(scene2, camera);

                // Clear the stencil mask, so that the rest of the rendering is unaffected
                const clearMaskPass = new ClearMaskPass();

                // Render the result to the screen
                const outputPass = new OutputPass();

                const parameters = {
					stencilBuffer: false
				};

				const renderTarget = new THREE.WebGLRenderTarget( window.innerWidth, window.innerHeight, parameters );

				composer = new EffectComposer( renderer );
                composer.addPass(clearPass);
                composer.addPass(maskPass1);
                composer.addPass(renderPass2);
                composer.addPass(clearMaskPass);
                composer.addPass(outputPass);


			}

			function onWindowResize() {

				const width = window.innerWidth;
				const height = window.innerHeight;

				camera.aspect = width / height;
				camera.updateProjectionMatrix();

				renderer.setSize( width, height );
				composer.setSize( width, height );

			}

			function animate() {

				requestAnimationFrame( animate );

				const time = performance.now() * 0.001 + 6000;
                
				box.position.x = Math.cos( time / 1.5 ) * 2;
				box.position.y = Math.sin( time ) * 2;
				box.rotation.x = time;
				box.rotation.y = time / 2;

				renderer.clear();
				composer.render();

			}

		</script>
	</body>
</html>